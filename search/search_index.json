{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DBW Good Book","text":"<p>The results taste a lot better than they look.</p>"},{"location":"getting_started/","title":"Getting Started","text":"<p>Welcome to the world of drive-by-wire. With code and microcontrollers, you can reproducibly write machines that perform arbitrarily complex sets of tasks on physical systems.</p> <p>Cooper has a suite of software and hardware through we which we make this happen. Originally, it was designed for Cooper IGVC, and is now open and available for everyone to use.</p>"},{"location":"getting_started/#computer-prep","title":"Computer Prep","text":"<p>You need a computer running Linux or macOS (and if you're running macOS, you probably still need a Linux VM).</p> <p>If you're running macOS:</p> <ol> <li>Install homebrew.</li> <li>Install virtual machine software, like Parallels (paid) or VMWare Fusion (free   for students).</li> </ol>"},{"location":"getting_started/#dependencies","title":"Dependencies","text":""},{"location":"getting_started/#code-editor","title":"Code editor","text":"<p>We recommend VS Code! The GitHub Themes extension is good.</p>"},{"location":"getting_started/#python-and-scons","title":"Python and SCons","text":"<ol> <li> <p>Python and pip</p> <p>If you're running macOS:</p> <pre><code>\u276f brew install python3\n</code></pre> <p>If you're running Linux, your distro probably already comes with a recent version of Python 3, but look up more specific instructions for your distro to make sure. Also ensure you have pip.</p> </li> <li> <p>SCons</p> <pre><code>\u276f pip3 install scons\n</code></pre> </li> </ol>"},{"location":"getting_started/#direnv","title":"<code>direnv</code>","text":"<p>On macOS: <pre><code>\u276f brew install direnv\n</code></pre></p> <p>On Linux, follow distro-specific instructions online.</p> <p>Then, follow the instructions to hook <code>direnv</code> into your shell.</p>"},{"location":"getting_started/#optional-cyme","title":"Optional: cyme","text":"<p>Cyme is a modern <code>lsusb</code> replacement. If you're on macOS: <pre><code>\u276f brew install tuna-f1sh/taps/cyme\n</code></pre></p> <p>If you're on Linux, you can run <code>cargo install cyme</code> if you have Rust installed.</p>"},{"location":"getting_started/#build-some-firmware","title":"Build Some Firmware","text":"<p>For now, we'll use the Cooper Motorsports repo as the example repository.</p>"},{"location":"getting_started/#clone-the-repository","title":"Clone the repository","text":"<p>Set up your ssh keys and:</p> <pre><code>\u276f git clone git@github.com:CooperUnion/motorsports.git\n</code></pre> <p>Great, you have the code!</p>"},{"location":"getting_started/#build-something","title":"Build something","text":"<p>Cool, now let's build something.</p> <p>Go ahead and: <pre><code>\u276f cd motorsports\n</code></pre></p> <p>You should see something like: <pre><code>\u276f cd motorsports\ndirenv: error /Users/dmezh/motorsports/.envrc is blocked. Run `direnv allow` to approve its content\n</code></pre></p> <p>Say: <pre><code>\u276f direnv allow\n</code></pre></p> <p>Now, you can run: <pre><code>\u276f fwpio run -e shutdown\n</code></pre></p> <p>And that will build the firmware for the <code>shutdown</code> Motorsports ECU \ud83e\udee1</p> <p>Remaining dependencies will be automatically managed by the build process.</p>"},{"location":"how_stuff_works/","title":"How Stuff Works","text":"<p>The basic rundown:</p> <ol> <li>Firmware is running on a microcontroller, which is a computer.</li> <li>Computers run programs, and the firmware is the program.</li> <li>Your computer has an operating system, like Linux or macOS. We also use an operating system. It's called FreeRTOS.</li> <li>In addition to FreeRTOS, we use libraries that let us do things like talk to peripherals (GPIO, CAN, ADCs, etc) on the chip. These are provided by the manufacturer of the microcontroller, Espressif.</li> <li>We write most of our stuff in C.</li> <li>We made a set of libraries on top of all this called Ember OS. One thing that gives you is <code>ember-tasking.</code></li> </ol>"},{"location":"how_stuff_works/#ember-tasking","title":"<code>ember-tasking</code>","text":"<p>All operating systems provide some kind of scheduling of different programs, since computers can really only do one thing at a time (barring multiple cores, which we won't discuss).</p> <p><code>ember-tasking</code> is a light layer above FreeRTOS and a hardware timer, plus a watchdog, that provides you with cyclic tasks. It makes this work:</p> <pre><code>#include &lt;stdio.h&gt;\n#include \"ember_common.h\"\n#include \"ember_taskglue.h\"\nstatic void example_init();\nstatic void example_1Hz();\nember_rate_funcs_S module_rf = {\n.call_init = example_init,\n.call_1Hz = example_1Hz,\n};\n/*\n * Runs once on bootup.\n */\nstatic void example_init()\n{\nprintf(\"Hello, I started up!\");\n}\n/*\n * Runs once every second.\n */\nstatic void example_1Hz()\n{\nprintf(\"Hello!\"); // printing \"Hello!\" to the terminal once a second\n}\n</code></pre>"},{"location":"how_stuff_works/#available-rates","title":"Available rates","text":"<p>You can specify a function to be called at initialization, and at 1, 10, 100, or 1000 Hz:</p> <pre><code>#include &lt;stdio.h&gt;\n#include \"ember_common.h\"\n#include \"ember_taskglue.h\"\nstatic void example_init();\nstatic void example_1Hz();\nstatic void example_10Hz();\nstatic void example_100Hz();\nstatic void example_1kHz();\nember_rate_funcs_S module_rf = {\n.call_init = example_init,\n.call_1Hz = example_1Hz,\n.call_10Hz = example_10Hz,\n.call_100Hz = example_100Hz,\n.call_1kHz = example_1kHz,\n};\n/*\n * Runs once on bootup.\n */\nstatic void example_init()\n{\nprintf(\"Hello, I started up!\");\n}\n/*\n * Runs once every second.\n */\nstatic void example_1Hz()\n{\nprintf(\"Hello!\"); // printing \"Hello!\" to the terminal once a second\n}\n/*\n * Runs at 10Hz.\n */\nstatic void example_10Hz()\n{\nprintf(\"Hello!\"); // printing \"Hello!\" to the terminal at 10Hz\n}\n...\n</code></pre>"},{"location":"how_stuff_works/#interruptibility","title":"Interruptibility","text":"<p>We need to get something out of the way.</p> <p>Computers can only do one thing at a time. You need to keep this rule in mind:</p> <p>Note</p> <p>You can be interrupted at any time. When you are interrupted, the CPU will run something else (e.g., a different cyclic function) and then resume wherever it left off.</p> <p>This means that while <code>example_1Hz</code> is running, it could be paused (interrupted), and <code>example_10Hz</code> could run. If you share data between cyclic tasks, you need to stay aware that the data could be modified when you might not expect it.</p> <p>Let's make some shared data and you'll see the problem:</p> <pre><code>static int i = 0;\nstatic void example_10Hz()\n{\ni = 123;\nprintf(\"10Hz: %d\", i);\n}\nstatic void example_100Hz()\n{\ni = 456;\nprintf(\"100Hz: %d\", i);\n}\n</code></pre> <p>if these tasks were not interruptible, you would expect to see output like <code>10Hz: 123</code> and <code>100Hz: 456</code> but say:</p> <ol> <li>You're running in <code>example_10Hz</code>. You set <code>i = 123</code>.</li> <li>You get interrupted before the <code>printf</code>. You're now running <code>example_100Hz</code>.</li> <li>You set <code>i = 456</code>.</li> <li>You print <code>100Hz: 456</code>.</li> <li>Execution resumes in <code>example_10Hz</code>.</li> <li>You read i, which is now 456, and print <code>10Hz: 456</code>.</li> </ol> <p><code>123</code> totally got lost!</p> <p>The same thing applies to shared hardware. If you're interacting with hardware, remember that you could be interrupted! It could be super important that you do two actions one after another without delay or something.</p> <p>Usually this stuff is not super annoying, even though it seems like it would be. Most of the time, you're only writing to a variable in one place and reading in another, and you can usually tolerate this kind of sloppy synchronization. The computer science nerds would call this eventual consistency.</p> <p>We battle this with a few tools:</p> <ul> <li> <p>Shared data must be marked <code>_Atomic</code>, which you can also spell as <code>atomic</code> if you <code>#include \"ember_common.h\"</code>. This doesn't solve data races, but it prevents individual variables from being corrupted by being half-read or half-written. The previous example really should say: <pre><code>static atomic int i = 0;\n</code></pre> Although this doesn't fix the problem, just prevents <code>i</code> from being corrupted.</p> </li> <li> <p>You can disable interrupts if you need to, which will guarantee you won't be interrupted. You must keep the time spent with interrupts disabled to a minimum, as interrupts are critical for keeping the system functioning. There is a limited number of functions you can call with interrupts disabled (for example, you can't call <code>printf</code>).</p> </li> </ul> <p>If you come up against this kind of synchronization challenge, please reach out to Dan. We'll have more extensive learning material on this in the future.</p>"},{"location":"how_stuff_works/#platformio","title":"PlatformIO","text":"<p>PlatformIO is a build system for embedded development projects. It rocks and we use it to build our projects. When you run <code>fwpio</code> (see Getting Started), that's running <code>pio</code>, which is how you interact with PlatformIO from the command line.</p> <p>The firmware is broken up into environments, which are defined in <code>platformio.ini</code>. Each environment is, in our case, a separate ECU.</p> <p>You can specify the environment to PlatformIO generally with <code>-e</code>. For example,</p> <pre><code>\u276f fwpio run -e precharge\n</code></pre> <p>Means \"PlatformIO: in environment <code>precharge</code>, run the default targets, which includes building the firmware.</p> <p>To specify additional targets, you can use <code>-t</code>:</p> <pre><code>\u276f fwpio run -e precharge -t upload\n</code></pre> <p>Means \"PlatformIO: in environment <code>precharge</code>, run the <code>upload</code> target\", which will upload firmware to a board attached to your computer.</p>"}]}